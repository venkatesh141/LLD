low level design

   Solid principles
   S - single responsibility principle
   O - open closed principle
   L - liskov substitution principle
   I - interface segeregation principle
   D - depending inversion principle
   
   
   ------------------trust the process
     
   Single responsibility principle
   
   
   Each class and module in a program should focus on a single task.
   
   for example if it is add function it should do only add it should not do more than that.
   
// Not following SRP
class UserService {
    void addUser(String user) {
        System.out.println("User added: " + user);
    }
    
    void saveToDatabase(String user) {
        System.out.println("User saved to database: " + user);
    }
}

// Following SRP
class UserService {
    void addUser(String user) {
        System.out.println("User added: " + user);
    }
}

class DatabaseService {
    void saveToDatabase(String user) {
        System.out.println("User saved to database: " + user);
    }
}


   
   ------------------trust the process
 
   Open closed principle(have to use interface )
   
      If we need to create a new  feature, we should not modify the existing code, we have to create seperate module or class to create a new feature.
Definition: A class should be open for extension but closed for modification.
      
// Not following OCP
class NotificationService {
    void sendNotification(String type, String message) {
        if (type.equals("Email")) {
            System.out.println("Email sent: " + message);
        } else if (type.equals("SMS")) {
            System.out.println("SMS sent: " + message);
        }
    }
}

// Following OCP
interface Notification {
    void send(String message);
}

class EmailNotification implements Notification {
    public void send(String message) {
        System.out.println("Email sent: " + message);
    }
}

class SMSNotification implements Notification {
    public void send(String message) {
        System.out.println("SMS sent: " + message);
    }
}

class NotificationService {
    void sendNotification(Notification notification, String message) {
        notification.send(message);
    }
}
 
   ------------------trust the process
   Liskov substitution princile

   It states that objectss of a superclass should be replaceable with objects
   of its subclass without affecting correctness of program

// Not following LSP
class Bird {
    void fly() {
        System.out.println("Flying...");
    }
}

class Penguin extends Bird {
    @Override
    void fly() {
        throw new UnsupportedOperationException("Penguins can't fly");
    }
}

// Following LSP
abstract class Bird {
    abstract void move();
}

class Sparrow extends Bird {
    void move() {
        System.out.println("Flying...");
    }
}

class Penguin extends Bird {
    void move() {
        System.out.println("Swimming...");
    }
}

   
    ------------------trust the process
    
    Interface segregation priciple

 oru interface la adhuku thevaya abstract methods matum dhaan irukanum unwanted methods iruka koodathu
Definition: A class should not be forced to implement interfaces it doesn't use.

// Not following ISP
interface Animal {
    void fly();
    void swim();
    void walk();
}

class Dog implements Animal {
    public void fly() {
        // Not applicable
    }

    public void swim() {
        System.out.println("Dog swims");
    }

    public void walk() {
        System.out.println("Dog walks");
    }
}

// Following ISP
interface Walkable {
    void walk();
}

interface Swimmable {
    void swim();
}

class Dog implements Walkable, Swimmable {
    public void walk() {
        System.out.println("Dog walks");
    }

    public void swim() {
        System.out.println("Dog swims");
    }
}

--------------------------------------------trust the process

Dependency inversio principle

       Definition: High-level modules should not depend on low-level modules; both should depend on abstractions.
// Not following DIP
class Keyboard {
    void type() {
        System.out.println("Typing...");
    }
}

class Computer {
    private Keyboard keyboard = new Keyboard();
    void start() {
        keyboard.type();
    }
}

// Following DIP
interface InputDevice {
    void type();
}

class Keyboard implements InputDevice {
    public void type() {
        System.out.println("Typing...");
    }
}

class Computer {
    private InputDevice inputDevice;
    
    Computer(InputDevice inputDevice) {
        this.inputDevice = inputDevice;
    }
    
    void start() {
        inputDevice.type();
    }
}

---------------------------------------------------trust the process
The Singleton Pattern ensures that a class has only one instance and provides a global point of access to that instance. 
This is useful when exactly one object is needed to coordinate actions across the system, such as a configuration manager or a logging utility.

How It Works
Private Constructor: To prevent creating multiple instances from outside the class.
Static Instance: A static variable holds the single instance of the class.
Public Getter Method: A public static method provides access to the single instance.

// Singleton class
class Singleton {
    // Step 1: Create a static variable to hold the single instance
    private static Singleton instance;

    // Step 2: Make the constructor private to prevent direct instantiation
    private Singleton() {
        System.out.println("Singleton instance created");
    }

    // Step 3: Provide a public static method to get the single instance
    public static Singleton getInstance() {
        if (instance == null) { // Create the instance if it doesn't exist
            instance = new Singleton();
        }
        return instance; // Return the single instance
    }

    // Example method to show functionality
    public void showMessage() {
        System.out.println("Hello from Singleton!");
    }
}

// Main class to test Singleton
public class Main {
    public static void main(String[] args) {
        // Get the single instance of Singleton
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();

        // Call a method on the Singleton instance
        singleton1.showMessage();

        // Verify that both references point to the same instance
        System.out.println(singleton1 == singleton2); // Output: true
    }
}

Key Points:
One Instance: The getInstance() method ensures only one instance is created.
Thread Safety (Optional for real-world use): For multi-threaded programs, synchronize the getInstance() method to avoid multiple threads creating separate instances.
Let me know if you'd like to see the thread-safe version or need further simplification!

. Database Connection Pool
Why Singleton? Managing connections to a database is resource-intensive.
 A Singleton ensures a single connection pool object is shared across the application.
Example Use Case: A single pool manages connections to a MySQL database in an e-commerce website.


------------------------------------------------------------trust the process


The Factory Method Pattern is a design pattern that allows a class to create objects without specifying their exact type. 
It provides a way to delegate the creation process to a separate method (factory), making the code flexible and easy to extend

interface Food {
    void prepare(); // All food items will implement this method
}

// Step 2: Create concrete classes for different food items
class Pizza implements Food {
    @Override
    public void prepare() {
        System.out.println("Preparing Pizza with cheese and toppings.");
    }
}

class Burger implements Food {
    @Override
    public void prepare() {
        System.out.println("Preparing Burger with lettuce and patties.");
    }
}

// Step 3: Create a Factory class with a method to produce food
class FoodFactory {
    // Factory Method
    public static Food getFood(String foodType) {
        if (foodType.equalsIgnoreCase("Pizza")) {
            return new Pizza();
        } else if (foodType.equalsIgnoreCase("Burger")) {
            return new Burger();
        } else {
            throw new IllegalArgumentException("Unknown food type");
        }
    }
}

// Step 4: Test the Factory Method
public class Main {
    public static void main(String[] args) {
        // Order Pizza
        Food pizza = FoodFactory.getFood("Pizza");
        pizza.prepare(); // Output: Preparing Pizza with cheese and toppings.

        // Order Burger
        Food burger = FoodFactory.getFood("Burger");
        burger.prepare(); // Output: Preparing Burger with lettuce and patties.
    }
}

Interface (Food): Defines the common behavior for all food items.
Concrete Classes (Pizza, Burger): These are the actual products.
Factory Class (FoodFactory): Contains the logic to decide which product (food) to create.
Client Code (Main): Uses the factory method to get the required object without knowing its exact class.

Key Points
Loose Coupling: The client code (Main) does not directly depend on the concrete classes (Pizza, Burger).
Flexibility: Adding new food types (e.g., "Pasta") only requires updating the factory method, not the client code.
------------------------------------------------------------trust the process

Abstract Factory Pattern - Simple Explanation
The Abstract Factory Pattern is like a factory of factories.
It provides an interface for creating families of related or dependent objects without specifying their concrete classes.

Code Example: Furniture Factory
Step 1: Define Abstract Product Interfaces
These are the common interfaces for related objects (e.g., Chair, Sofa).

java
Copy code
// Abstract product: Chair
interface Chair {
    void sitOn();
}

// Abstract product: Sofa
interface Sofa {
    void relaxOn();
}
Step 2: Create Concrete Products
These are specific implementations of the abstract products.

java
Copy code
// Modern chair implementation
class ModernChair implements Chair {
    @Override
    public void sitOn() {
        System.out.println("Sitting on a modern chair.");
    }
}

// Victorian chair implementation
class VictorianChair implements Chair {
    @Override
    public void sitOn() {
        System.out.println("Sitting on a Victorian chair.");
    }
}

// Modern sofa implementation
class ModernSofa implements Sofa {
    @Override
    public void relaxOn() {
        System.out.println("Relaxing on a modern sofa.");
    }
}

// Victorian sofa implementation
class VictorianSofa implements Sofa {
    @Override
    public void relaxOn() {
        System.out.println("Relaxing on a Victorian sofa.");
    }
}
Step 3: Define the Abstract Factory
This factory will create families of related products.

java
Copy code
// Abstract Factory
interface FurnitureFactory {
    Chair createChair();
    Sofa createSofa();
}
Step 4: Create Concrete Factories
These factories implement the creation logic for specific product families.

java
Copy code
// Modern furniture factory
class ModernFurnitureFactory implements FurnitureFactory {
    @Override
    public Chair createChair() {
        return new ModernChair();
    }

    @Override
    public Sofa createSofa() {
        return new ModernSofa();
    }
}

// Victorian furniture factory
class VictorianFurnitureFactory implements FurnitureFactory {
    @Override
    public Chair createChair() {
        return new VictorianChair();
    }

    @Override
    public Sofa createSofa() {
        return new VictorianSofa();
    }
}
Step 5: Client Code
The client uses the factory to create objects without knowing their exact types.

java
Copy code
public class Main {
    public static void main(String[] args) {
        // Get a modern furniture factory
        FurnitureFactory modernFactory = new ModernFurnitureFactory();
        Chair modernChair = modernFactory.createChair();
        Sofa modernSofa = modernFactory.createSofa();

        modernChair.sitOn();  // Output: Sitting on a modern chair.
        modernSofa.relaxOn(); // Output: Relaxing on a modern sofa.

        // Get a Victorian furniture factory
        FurnitureFactory victorianFactory = new VictorianFurnitureFactory();
        Chair victorianChair = victorianFactory.createChair();
        Sofa victorianSofa = victorianFactory.createSofa();

        victorianChair.sitOn();  // Output: Sitting on a Victorian chair.
        victorianSofa.relaxOn(); // Output: Relaxing on a Victorian sofa.
    }
}
Key Points
Abstract Factory: Defines the interface for creating families of related objects.
Concrete Factories: Implement the creation logic for specific product families.
Client Code: Works with factories and products using their abstract interfaces, making it independent of concrete implementations.

Payment Gateways
Why Abstract Factory?
Different payment gateways (e.g., PayPal, Stripe, Razorpay) require different APIs and objects for processing payments.
Example Use Case:
An e-commerce platform uses an Abstract Factory to create objects for different payment processors based on the user's choice.
------------------------------------------------------------trust the process







   
   
        
      
      
